/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */
 
function SimpleTimer() {
	this.sec = 0;  
	this.mins = 0;
	this.hour = 0;
	this.ticking = false;

	this.start = function() {
		if(this.ticking!=true) {
			this.ticking=true;
			this.tick();
		}
	}

	this.pause = function() {
		this.ticking = false;
	}

	this.tick = function(){
		if (this.ticking==true) {
			this.sec++;
			
			if (this.sec == 60) {
				this.sec = 0;
				this.mins++;
			}

			if (this.mins == 60) {
				this.mins = 0;
				this.hour++;
			}

			this.setStopwatchGUIValue();

			window.setTimeout("simpleTimer.tick();", 1000);
		}
	}

	this.reset = function() {   
		if(!this.ticking) {
            this.sec = 0;
            this.mins = 0;
            this.hour = 0;
            this.setStopwatchGUIValue();
        }
        
	}

	this.setStopwatchGUIValue = function() {
		document.getElementById('timer').innerHTML = ((this.hour<=9) ? "0"+this.hour : this.hour) + ":" + ((this.mins<=9) ? "0" + this.mins : this.mins) + ":" + ((this.sec<=9) ? "0" + this.sec : this.sec);
	}
}

var simpleTimer = new SimpleTimer();

function BuildStatus() {
    this.good = function() {
        simpleTimer.pause();
        this.resetStatusWithColor('#7ACC8F');
        document.getElementById("good").classList.remove("hidden");
    }
    
    this.bad = function() {
        simpleTimer.pause();
        this.resetStatusWithColor('#FF0000');
        document.getElementById("bad").classList.remove("hidden");
    }
    
    this.updating = function() {
        simpleTimer.reset();
        simpleTimer.start();
        this.resetStatusWithColor('#2B66C9');
        document.getElementById("updating").classList.remove("hidden");
    }
    
    this.compiling = function() {
        simpleTimer.reset();
        simpleTimer.start();
        this.resetStatusWithColor('#2B66C9'); 
        document.getElementById("compiling").classList.remove("hidden");
    }
    
    this.testing = function() {
        simpleTimer.reset();
        simpleTimer.start();
        this.resetStatusWithColor('#2B66C9');
        document.getElementById("testing").classList.remove("hidden");
    }

    this.resetStatusWithColor = function(color) {
        this.hideAllStatuses();
        document.getElementById("outerFrontContainer").style.background = color;
    }

    this.hideAllStatuses = function() {
        document.getElementById("good").classList.add("hidden");
        document.getElementById("bad").classList.add("hidden");
        document.getElementById("updating").classList.add("hidden");
        document.getElementById("compiling").classList.add("hidden");
        document.getElementById("testing").classList.add("hidden");
    }
}

var buildStatus = new BuildStatus();

document.getElementById("MyElement").className = "MyClass";

var rubyTelnetServerCommand;

function onSystemEnd() {
    
}

function onSystemReadOutput(data) {
    data=data.trim();
    switch(data) {
        case "good" :
            buildStatus.good();
            break;
        case "bad" :
            buildStatus.bad();
            break;
        case "updating" :
            buildStatus.updating();
            break;
        case "compiling" :
            buildStatus.compiling();
            break;
        case "testing" :
            buildStatus.testing();
            break;
    }
    document.getElementById("msgText").innerText = data;
}

function onSystemReadError(data) {
    document.getElementById("msgText").innerText = data;
}

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();
    
    rubyTelnetServerCommand = widget.system("/usr/bin/ruby server.rb", onSystemEnd);
    rubyTelnetServerCommand.onreadoutput = onSystemReadOutput;
    rubyTelnetServerCommand.onreaderror = onSystemReadError;
}



//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    rubyTelnetServerCommand.stop();
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // Stop any timers to prevent CPU usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Restart any timers that were stopped on hide
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display = "none";
    back.style.display = "block";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToFront");
    }

    front.style.display="block";
    back.style.display="none";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}
